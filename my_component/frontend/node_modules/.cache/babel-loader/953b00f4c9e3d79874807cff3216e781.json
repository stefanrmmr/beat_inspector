{"ast":null,"code":"import{Streamlit}from\"streamlit-component-lib\";// Add text and a button to the DOM.\n// (You could also add these directly to index.html.)\nvar span=document.body.appendChild(document.createElement(\"span\"));var textNode=span.appendChild(document.createTextNode(\"\"));var button_rec=span.appendChild(document.createElement(\"button\"));var button_done=span.appendChild(document.createElement(\"button\"));var button_reset=span.appendChild(document.createElement(\"button\"));button_rec.textContent=\"record\";button_done.textContent=\"done\";button_reset.textContent=\"reset\";// Add a click handler to our button. It will send data back to Streamlit.\nvar isFocused=false;var output=[1,'audiofile_string_demo'];button_rec.onclick=function(){output[0]+=1;// Works!\n// component value is the return variable given to back to streamlit\nStreamlit.setComponentValue(output);};button_rec.onfocus=function(){isFocused=true;};button_rec.onblur=function(){isFocused=false;};/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */function onRender(event){// Get the RenderData from the event\nvar data=event.detail;// Maintain compatibility with older versions of Streamlit that don't send\n// a theme object.\nif(data.theme){// Use CSS vars to style our button border. Alternatively, the theme style\n// is defined in the data.theme object.\nvar borderStyling=\"1px solid var(\".concat(isFocused?\"--primary-color\":\"gray\",\")\");button_rec.style.border=borderStyling;button_rec.style.outline=borderStyling;}// Disable our button if necessary.\nbutton_rec.disabled=data.disabled;// RenderData.args is the JSON dict of arguments sent from the Python script.\nvar name=data.args[\"name\"];// Show \"Hello, name!\" with a non-breaking space afterwards.\ntextNode.textContent=\"Hello, \".concat(name,\"! \")+String.fromCharCode(160);// We tell Streamlit to update our frameHeight after each render event, in\n// case it has changed. (This isn't strictly necessary for the example\n// because our height stays fixed, but this is a low-cost function, so\n// there's no harm in doing it redundantly.)\nStreamlit.setFrameHeight();}// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT,onRender);// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady();// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight();","map":{"version":3,"sources":["/Users/stefan_rmmr/software_dev/beat_inspector/my_component/frontend/src/index.tsx"],"names":["Streamlit","span","document","body","appendChild","createElement","textNode","createTextNode","button_rec","button_done","button_reset","textContent","isFocused","output","onclick","setComponentValue","onfocus","onblur","onRender","event","data","detail","theme","borderStyling","style","border","outline","disabled","name","args","String","fromCharCode","setFrameHeight","events","addEventListener","RENDER_EVENT","setComponentReady"],"mappings":"AAAA,OAASA,SAAT,KAAsC,yBAAtC,CAEA;AACA;AACA,GAAMC,CAAAA,IAAI,CAAGC,QAAQ,CAACC,IAAT,CAAcC,WAAd,CAA0BF,QAAQ,CAACG,aAAT,CAAuB,MAAvB,CAA1B,CAAb,CACA,GAAMC,CAAAA,QAAQ,CAAGL,IAAI,CAACG,WAAL,CAAiBF,QAAQ,CAACK,cAAT,CAAwB,EAAxB,CAAjB,CAAjB,CAEA,GAAMC,CAAAA,UAAU,CAAGP,IAAI,CAACG,WAAL,CAAiBF,QAAQ,CAACG,aAAT,CAAuB,QAAvB,CAAjB,CAAnB,CACA,GAAMI,CAAAA,WAAW,CAAGR,IAAI,CAACG,WAAL,CAAiBF,QAAQ,CAACG,aAAT,CAAuB,QAAvB,CAAjB,CAApB,CACA,GAAMK,CAAAA,YAAY,CAAGT,IAAI,CAACG,WAAL,CAAiBF,QAAQ,CAACG,aAAT,CAAuB,QAAvB,CAAjB,CAArB,CACAG,UAAU,CAACG,WAAX,CAAyB,QAAzB,CACAF,WAAW,CAACE,WAAZ,CAA0B,MAA1B,CACAD,YAAY,CAACC,WAAb,CAA2B,OAA3B,CAEA;AACA,GAAIC,CAAAA,SAAS,CAAG,KAAhB,CACA,GAAIC,CAAAA,MAAwB,CAAG,CAAC,CAAD,CAAI,uBAAJ,CAA/B,CAEAL,UAAU,CAACM,OAAX,CAAqB,UAAiB,CACpCD,MAAM,CAAC,CAAD,CAAN,EAAa,CAAb,CAAoB;AACpB;AACAb,SAAS,CAACe,iBAAV,CAA4BF,MAA5B,EACD,CAJD,CAMAL,UAAU,CAACQ,OAAX,CAAqB,UAAiB,CACpCJ,SAAS,CAAG,IAAZ,CACD,CAFD,CAIAJ,UAAU,CAACS,MAAX,CAAoB,UAAiB,CACnCL,SAAS,CAAG,KAAZ,CACD,CAFD,CAIA;AACA;AACA;AACA;AACA,GACA,QAASM,CAAAA,QAAT,CAAkBC,KAAlB,CAAsC,CACpC;AACA,GAAMC,CAAAA,IAAI,CAAID,KAAD,CAAmCE,MAAhD,CAEA;AACA;AACA,GAAID,IAAI,CAACE,KAAT,CAAgB,CACd;AACA;AACA,GAAMC,CAAAA,aAAa,yBACjBX,SAAS,CAAG,iBAAH,CAAuB,MADf,KAAnB,CAGAJ,UAAU,CAACgB,KAAX,CAAiBC,MAAjB,CAA0BF,aAA1B,CACAf,UAAU,CAACgB,KAAX,CAAiBE,OAAjB,CAA2BH,aAA3B,CACD,CAED;AACAf,UAAU,CAACmB,QAAX,CAAsBP,IAAI,CAACO,QAA3B,CAEA;AACA,GAAIC,CAAAA,IAAI,CAAGR,IAAI,CAACS,IAAL,CAAU,MAAV,CAAX,CAEA;AACAvB,QAAQ,CAACK,WAAT,CAAuB,iBAAUiB,IAAV,OAAqBE,MAAM,CAACC,YAAP,CAAoB,GAApB,CAA5C,CAEA;AACA;AACA;AACA;AACA/B,SAAS,CAACgC,cAAV,GACD,CAED;AACAhC,SAAS,CAACiC,MAAV,CAAiBC,gBAAjB,CAAkClC,SAAS,CAACmC,YAA5C,CAA0DjB,QAA1D,EAEA;AACA;AACAlB,SAAS,CAACoC,iBAAV,GAEA;AACA;AACApC,SAAS,CAACgC,cAAV","sourcesContent":["import { Streamlit, RenderData } from \"streamlit-component-lib\"\n\n// Add text and a button to the DOM.\n// (You could also add these directly to index.html.)\nconst span = document.body.appendChild(document.createElement(\"span\"))\nconst textNode = span.appendChild(document.createTextNode(\"\"))\n\nconst button_rec = span.appendChild(document.createElement(\"button\"))\nconst button_done = span.appendChild(document.createElement(\"button\"))\nconst button_reset = span.appendChild(document.createElement(\"button\"))\nbutton_rec.textContent = \"record\"\nbutton_done.textContent = \"done\"\nbutton_reset.textContent = \"reset\"\n\n// Add a click handler to our button. It will send data back to Streamlit.\nlet isFocused = false\nlet output: [number, string] = [1, 'audiofile_string_demo'];\n\nbutton_rec.onclick = function(): void {\n  output[0] += 1;     // Works!\n  // component value is the return variable given to back to streamlit\n  Streamlit.setComponentValue(output)\n}\n\nbutton_rec.onfocus = function(): void {\n  isFocused = true\n}\n\nbutton_rec.onblur = function(): void {\n  isFocused = false\n}\n\n/**\n * The component's render function. This will be called immediately after\n * the component is initially loaded, and then again every time the\n * component gets new data from Python.\n */\nfunction onRender(event: Event): void {\n  // Get the RenderData from the event\n  const data = (event as CustomEvent<RenderData>).detail\n\n  // Maintain compatibility with older versions of Streamlit that don't send\n  // a theme object.\n  if (data.theme) {\n    // Use CSS vars to style our button border. Alternatively, the theme style\n    // is defined in the data.theme object.\n    const borderStyling = `1px solid var(${\n      isFocused ? \"--primary-color\" : \"gray\"\n    })`\n    button_rec.style.border = borderStyling\n    button_rec.style.outline = borderStyling\n  }\n\n  // Disable our button if necessary.\n  button_rec.disabled = data.disabled\n\n  // RenderData.args is the JSON dict of arguments sent from the Python script.\n  let name = data.args[\"name\"]\n\n  // Show \"Hello, name!\" with a non-breaking space afterwards.\n  textNode.textContent = `Hello, ${name}! ` + String.fromCharCode(160)\n\n  // We tell Streamlit to update our frameHeight after each render event, in\n  // case it has changed. (This isn't strictly necessary for the example\n  // because our height stays fixed, but this is a low-cost function, so\n  // there's no harm in doing it redundantly.)\n  Streamlit.setFrameHeight()\n}\n\n// Attach our `onRender` handler to Streamlit's render event.\nStreamlit.events.addEventListener(Streamlit.RENDER_EVENT, onRender)\n\n// Tell Streamlit we're ready to start receiving data. We won't get our\n// first RENDER_EVENT until we call this function.\nStreamlit.setComponentReady()\n\n// Finally, tell Streamlit to update our initial height. We omit the\n// `height` parameter here to have it default to our scrollHeight.\nStreamlit.setFrameHeight()\n"]},"metadata":{},"sourceType":"module"}